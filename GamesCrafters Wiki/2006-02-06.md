2006-02-06
==========

REMINDERS/HOMEWORK:
-------------------

1. Send your info if you have not done so!

2. New Games: Play your game.

Meeting Minutes
---------------

GamesCrafters, 5-9pm, 2006-02-06 @ 5-9PM

606 Soda

1. Pictures

2. Attendance

3. Solvers (cont.)

4. Hash function –help new gamers with their hashes!

3. Solvers

-Last time: normal, loop-free DFS solver (solvestd.c)

-Last time: normal, loopy solver with parents

-Today: Mario loopy solver

Zero memory solver BFS solver

LIFO vs. FIFO

FIFO: first in, first out LIFO: last in, first out

Extra data structures

.......

&lt;---a (children: bcde)

.......

“children to explore” queue

Zero memory:

Why write it: run out of memory when solving!

Q. How dfs know how to “back up”?

-Natural built in recursion

-Bfs is an iterative process where I keep queue of who the children are. If see them before then ignore it.

Q. So how is it a zero memory solver, if bfs by own nature is extra data structure?

-It sweeps through layer by layer

-For free I get stack frames, which help with the recursion

How does Scott’s work differently?

-lecture by Dom

Picture:

Position array, which stores values.

-Somewhere in there is gInitPos, which marks things as valid values. It marks it as visited once it hits them. Starts off with InitPos, finds children, marks them as visited and does a depth first search type.

-At first it will not know which value will actually be hit. Try to make it as tight as possible with hash, but a lot of values will not be valid game position. (Example: xxx, or ooo as three in a row..but will not occur ever).

-He could to a quick depth first to mark initial position to save time. A lot of first iteration is to get to bottom of the tree. Each time it hits known, it asks if it knows the value (for all visited). If not, it asks is it primitive?

-If it is not primitive, then it ignores it and keeps going. Eventually it will hit all the primitives, which will have some sort of value.

-Once it gets all the primitives, it can start solving for positions above that. For each position it will look at the children, and ask if all the children are solved for and if it can decide what position. If it can, it gives it a value.

-He does not jump from position to position. He can be looking at initial position and bottom nodes at one sweep (he does not need to remember his path, which is a problem in loopy games). This way it is sort of a bottom up way.

Summary:

1. Visit all positions (breath first or depth first search) from 0 to max

2. If(Visited){

If(!HasValue){

If(Primitive)

SetValue

else if(ChildrenSolved)

SetValue

}

}

3. Repeat Till Nothing Changes

4. Set all Visited without value as a DRAW

Recursive definition for remoteness for losing position: One plus the max remoteness of all children.

How do I ask primitive if I only have a number. You need to unhash it. This cost you something. That is why always asking primitive is costly.

What ends up happening with this? It is a bottom up solver. What it does is sweep through all positions. It hits the primitives, then all the guys who have all children as primitives (ttt: board is full except for one)

-it will keep doing this, with no extra data structure.

Dumb way to make this faster? Rather than 0-max, ask what is smallest number ever visited and loop from the smallest number.

Mario:

-The algorithm works sort of like the current solver, which was doing a bfs instead of dfs.

-It records edges, how to get from a child to a parent and traverses the entire graphs. It records the values of the primitive positions and at the end puts all primitive in a frontier.

-Then there is a second step, which is frontier expansion where the frontier moves up, grabs new nodes and discards the old ones.

-Back edges not in concrete data structure, will be generated by domove.

-In summary, it is exactly the same algorithm, with the only implementation detail that is different is the reverse edge. Mario's proposal is to generate it procedurally rather then use the recorded data structure in memory.

Table-values for C:

C B A

W D D L W L T

Evan: bottom up solver

-needs Scott's database

-currently supports non-loopy only

-SolveloopyBU

Typical game tree (picture: see board)

-Total stages: there are several helper functions to return total number of stages and positions in one stage (enumerate within stage) the solver gets the total number of stages first and does a simple for loop

For(S<totalstage; s>=0;S--)

P=Enumerate (S)

While (P!=null)

DetermineValue(P.position)

-then go to next stage and get all those positions and look at them

-not care if position is valid or not.

Why did Evan start this?

-weakly solved, but not strongly solved (C4)

Evan job was to look at Connect4 and dartboard like games (when place a piece it does not move). The catch is to attack dartboard problem by walking up. What is brilliant is that there is an enumeration: there is no state here! With no state what can you do? You can spread them out. Can send stuff to computers.

-this can be low memory: all care about is a slice at a time.

What Evan is doing is list of position so he can come up with whatever file format he wants. He does not have to wait for rest of the team to get their thing working.

Games we must solve this semester! (w/ difficulty level)

1. Topitop (3) : 2 people

2. Bagh Chal! (history: coded as dragon and swans, it died). –talk to Dom

-Attempt at four person game: 4x4 board (Bagh Chal Lite swan.c)

-Bagh chal mini

-Bagh chal (baghchal.c) want to solve the whole game (4x4 first, then 5x5): 2 people

3. Quarto: 3 people

4. Nine Men’s Morris: one person

-Rules: starts off with nine pieces, take turns, every time make mill, remove one person pieces, slide to open adjacent spots. When one is at three pieces left, can stay sliding or fly to any other open spot on board.

Games: to make pb for:

quick chess (2)

What other games that are active:

Repel team: try work on it on their own.

Rubix checkers

Hash functions:

1. Talk about games: rebel, cambio, quick chess, topitop:

Topitop: Have 3x3 board with three different pieces: small sandcastle, large sandcastle and a red or blue bucket. The sandcastles are shared pieces. Goal: make 2 sandcastles with bucket on top (small, large, bucket). 2 buckets per person (hash next week)

Repel team: Jason

-like ttt, except it is on 4x4. There are two sides of the board, each player sit on one side of the board. Purple or red and white pieces. The goal is to get two three in a rows of one of white and one of color. Catch: can repel player piece. -each player has nine pieces. If one uses up all nine pieces, the other can play until you get your pieces back. -there are also power pieces that cannot be repelled -either create two boards to visualize or half circles to represent stuff.

Cambio:

Albert and Simon

-5x5 board: in the beginning set up the board, with stars on the corners. Player a has to use player b symbols. He places them anywhere on the board. Do not put five in a row, b/c that is winning position.

Player b goes second, and uses players a’s pieces (only put four b/c first player has an advantage). Fill the rest with neutral symbols.

Quick chess: Aaron and Adam

Smaller version of chess. Same pieces, but much fewer. 5x6 board. Two fewer ranks, two fewer files. -6 pieces

Setup: RBKQN PPPPP

PPPPP RBKQN

-no castling, pawns cannot advance 2 squares on first move, promotion permitted

Rubik’s checkers:

Like checkers except use half the pieces and start out with kings. Each piece has two sides: a man and a king. All pieces start as kings in beginning. Kings can move diagonally or backwards. You can jump like in checkers, except you do not die immediately. Rather, the king gets demoted into a man. As a man the piece can only retreat backwards and cannot jump. If the man gets jumped, he dies. If you can get your man back to home row, he can be re-promoted. Goal: Either kill opposing side or he cannot move (trap him). -flaw to the game: there is a simple strategy that is unbeatable. You can play defense and no one can get you Like in abalone.

Hash functions! Qchess: 5x6 board: How hash it into numbers? Use Generic Hash!

GenericHash (P,0,5 (R,0,1 (B,0,1 (Q,0,1 \[this is the same for red\] (n,0,1 (K 1 1 (P 0 5…

Hash(lRBKQNPPPPPP….. -10,28,’-')

-   Rubik’s Checkers:

6x4 board

- Generic hash:

‘p’, 0,8, a ‘k’,0,8, b ‘p’,0,8, c ‘k’, 0,8, d ‘-‘,8,23, e

A+b&lt;=8

C+d&lt;=8

B+d&gt;=1 -loopy and partisan

-   Cambio:

5x5 board. Corners are neutral.

-Use Generic Hash-

25

‘o’,0,20, a

‘x’,0,20, b

‘-‘,0,25, c

Rules: X==0 and o&lt;5 Or o==5 and o&lt;=x&lt;=3 or x&gt;=4 and o&gt;=5

-Loopy and partisan
