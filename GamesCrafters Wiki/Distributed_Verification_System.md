Distributed\_Verification\_System
=================================

Overview
========

We created a testing framework for the verification of databases generated by various solvers for different games. Currently, the framework only supports Connect 4.

Members
-------

-   **Alex Degtiar**
-   **Royce Cheng-Yue**

Database Verification Process
-----------------------------

We verify two aspects of a solved database: tree consistency and primitive positions.

### Tree Consistency

Tree consistency ensures that the value of a position corresponds correctly to the values of its children. The verifier calculates the correct value of the position based on the stored values of the position's children in the database, and then checks that it matches the position's value in the database.

### Primitive Positions

The verifier checks that the true value of a primitive position in the game matches that in the database. It also checks to ensure that the remoteness of the position in the database is 0.

Verifiers
---------

We created two different types of verifiers: a random verifier and a backtracking verifier. We hope that these verifiers will be useful in determining whether or not certain solvers are solving games correctly.

#### Random

The intent of the random verifier is to stochastically verify games whose state space is too large to fully explore. Instead of traversing the entire tree and verifying each position (i.e. backtrack verifier), the intent of the random verifier is to repeatedly perform random walks of the tree and maximize tree coverage. While this method of verification is not effective at checking every single position in a game, it attempts to explore the tree as evenly as possible. If erroneous values cover larger areas of the tree, they are likely to be found quickly.

To mitigate the effects of redundant verification, we approximate the probability of having already verified a particular position, and use this to decide whether or not to verify that position. The decision is random, with the likely hood of verifying that position being the approximated 1 - P(position has already been verified). This optimization allows us to minimize the chance of re-scanning already verified positions.

#### Backtrack

The intent of the backtrack verifier is to fully verify every single position in a game. This would typically be in a game in which the state space is small enough to fully explore and verify in a reasonable amount of it. The backtrack verifier does an preorder traversal of the game tree and verifies each position exactly once. When it encounters a primitive position, instead of restarting the search, it backtracks until it gets to an unvisited position and continues.

Testing
-------

To ensure that our testing framework works, we re-solved an small Connect 4 game and stored incorrect values of both types for certain positions into the database. When we ran our verifiers on these incorrect databases, both verifiers were able to catch all incorrect positions/values.

The code
--------

Verification code can be found in the *edu.berkeley.gamesman.verification* package of Gamesman Java.

Future Plans
------------

For the future, we may want to add other types of verifiers for different verification purposes (i.e. to target certain parts of the game tree). We may also want to add other games to expand the number of games we can test. Other improvements to the verifier is to make the verification process parallel, and optimize the database accesses.

Questions
---------

1. What types of error is such a verification tool supposed to catch? To me, it seems that this would catch database corruption, but thats it. The real source of errors in our case is the corner cases of primitive. In many games primitive is not a simple function and in some random unthought of scenario may have an error. How do we catch such a mistake? 2. The other possible purpose of such a tool is to verify a solver. In the case that the solver is making an assumption that it ought not to make, this may catch it. However, is this really a problem?
